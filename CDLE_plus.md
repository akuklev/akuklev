Давайте-ка поделюсь — в рамках нашей деятельности по теориям типов, я сейчас экспериментирую со следующей системой вселенных:
Базовая система, с которой мы будем стартовать, это quantitative type theory, где всего два количественных сорта: обычные переменные, которые можно использовать сколько угодно раз в теле функции, и параметры которые можно использовать в теле ноль раз. Соответственно имеются два сорта типов — data types для обычных перменных и virtual types для параметров. Любой data type `T` можно сконвертировать в virtual type записью 0T. Имеется virtual type ∗, называемый импредикативной вселенной. Его элементы `T : ∗` — все data types.
Для любого типа виртуального типа ϰ существует виртуальный тип `ϰ -> ∗` полиморфных типов с параметром типа ϰ. К примеру когда мы сможем определить полиморфный тип `List[T : ∗] : ∗`, то это мы как раз будем определять `List : ∗ -> ∗`, а когда `Array[length : Nat, T : ∗] : ∗`, то `Array : 0Nat -> ∗ -> ∗`. У полиморфных типов могут быть и ещё более экзотические сигнатуры, такие как например  `(∗ -> ∗) -> ∗` или `(0Nat -> ∗) -> ∗`. Допускаются и зависимые сигнатуры `(T : ∗) -> 0(Monad T) -> ∗`.
Виртуальные типы не являются элементами других типов, в частности мы не можем написать `∗ : ∗`, это не работает чисто синтаксически.
Кроме всего этого у нас есть иерархия специальных вложенных друг в друга типов данных, не имеющих элиминаторов, U ⊂ U' ⊂ U'' ⊂ ···, называемых предикативными вселенными, со свойством 0U => ∗ независимо от числа штрихов. (В целом можно рассматривать ∗ просто как краткое обозначение 0U.) Т.е. любая предикативная вселенная, будучи сконвертирована в виртуальный тип, превращается в импредикативную вселенную. Из этого следует две вещи:
– элементы предикативных вселенных можно подставлять как типы данных в качестве параметров полиморфных типов и полиморфных функций (типа `map : (X Y : ∗) -> (X -> Y) -> List[X] -> List[Y]`),
- функции с аргументами типа `U`, ни разу не используемыми в теле функции, автоматически являются полиморфными по типу, например вышеуказанный map определяется через `\X \Y : 0U \f : (X -> Y) ...`. Это манифестация принципа рефлексии “если мы что-то доказываем для той или иной предикативной вселенной, нигде не пользуясь её малостью, то результат верен и для импредикативной вселенной в целом”. Так показав лему йонеды для U-малых категорий (которые, в отличие от категорий неограниченного размера, можно, например, возвращать как единое целое) мы автоматически получим также и утверждение для категорий без ограничения размера.
Кроме этого, для _замкнутых_ (т.е. определённых в пустом контексте) возвращающих U-малые типы функций `t : P -> U`, где `U` любая вселенная, а `P` может содержать упоминания `U`, есть специальная операция “обобщения” — превращения функции в полиморфный тип: `<t> : P -> ∗`, где все упоминания `U` в `P` заменяются на ∗. Т.е. например эндофункция `f : U -> U` на любой из вселенных превращается в полиморфный тип `<f> : ∗ -> ∗`.
– Вселенные замкнуты относительно формирования индуктивных типов.
– Каждая последующая вселенная U' замкнута относительно всех полиморфных типов, определимых при помощи предыдущей вселенной (т.е. является вселенной Mahlo), а также содержит
1) код для предыдущей вселенной `u`, `<u> = U`;
2) для каждого индуктивного типа из `U` тип его зависимых элиминаторов.
Иными словами, можно сказать, что каждая последующая вселенная содержит все типы, определнные до неё, плюс замкнута относительно всех определенных до неё полиморфных типов. Это позволяет сформулирвоать метатеоретическое утверждение, что для каждого типа данных найдется вселенная, его содержащая.
Из указанных выше определний следует, что базовая вселенная `U` содержит в точности все счётные индуктивные типы с разрешимым равенством. Поднимая замкнутые функции на этом типе мы можем получить такие полиморфные типы как `Pair : ∗ -> ∗ -> ∗`, `Either : ∗ -> ∗ -> ∗`, `List : ∗ -> ∗` и `Array : Nat -> ∗ -> ∗`. Более того, такие типы как `List[Nat]` уже содержатся в первой вселенной, ведь они тоже счётные индуктивные типы с разрешимым равенством.
Следующая вселенная `U'` содержит кроме этого все обыкновенные и зависимые функции между такими типами, например функции `Nat -> Nat`. Будучи замкнутой относительно полиморфных типов, определимых при помощи предыдущей вселенной, она также содержит такие типы как `List[Nat -> Nat]` и `List[U]`, не содержащиеся в базовой вселенной `U`.
Среди полиморфных типов, определимых при помощи этой вселенной функции (-> : ∗ -> ∗ -> ∗), оставшиеся неопределёнными  логические операторы ¬ и ∨, и все кванторы `∀ Σ ∃ ∄ : (X : ∗) -> (Y : X -> ∗) -> ∗`.
Следующая вселенная U'' уже замкнута относительно всего этого и содержит полноценную подвселенную утверждений Prop. Если под “индуктивными типами” мы на самом деле понимаем “высшие индуктивно-индуктивные типы с правилами редукции”, то эта вселенная также содержит, например, вещественные числа `Real` вместе с функциями между ними, а в качестве полиморфных типов позволяет определять такие интересные штуки как монаду частичных тьюринг-полных вычислений `℧ : ∗ -> ∗` и предпучки на вполне-упорядоченных категориях `(I : C) -> (D(I) -> T)`, в т.ч. семисимплициальные типы.
Возможные пути усиления теории:
1) выделение типа `Prop := (T : U'', isProp(T))` с постулированием, что все утверждения из более старших вселенных уже содержатся в этом типе.
2) добавление возможности использовать аксиому выбора и, сответственно, исключенное третье для термов 0Prop.
3) добавление возможности использовать термы 0Prop в качестве хинтов для termination checker'а.
В совокупности всё это предположительно обратит теорию в консервативное расширение ZMC/S, соответственно покажет её эквиконсистентность с ZFC + Mahlo cardinals.
Открытые вопросы:
1) Действительно ли это работает?
2) Можно ли добиться, чтобы все предикативные вселенные оказались унивалентными не портя вычислимость теории?
3) Как элегантно добавить Equaliser Coinductive Types и расширить индуктивные типы до directed fibered inductive inductive?
