(Ко)Монады в программировании
=============================

При создании библиотек, фреймворков и API часто встречаются ситуации, когда желательно принимать в качестве аргумента блок исполняемого кода.
Возьмём хотя бы функцию `filter(collection, condition)`, фильтрующую какой-то набор значений фиксированного типа `T` при помощи условия `condition`.
Можно, конечно, обойтись каким-то конечным или конечно-порождённым набором условий, но для достижения максимальной общности нам нужно допускать в
качестве условия произвольный изолированно исполянемый блок кода `condition : T -> Boolean`, который можно применить к любому значению типа `T` и получить ответ — убрать его из набора или оставить. Иногда этого не хватает, и нужно чтобы принимаемый “блок исполняемого кода” мог содержать дополнительные операции.
Например `warn(msg : String)` и `fail(msg : String)` или `setStatus(s : S)` и `getStatus() :  S`.

Прежде чем я продолжать, давайте договоримся об обозначениях. Обозначение `f : X -> Y` мы будем использовать для настоящих (как в математике) функций
из типа `X` в тип `Y`. В частности, изолированно исполняемый (в смысле, можно отослать на сервер на Марсе, и исполнять там) блок кода, принимающий `x : X` и возвращающий `y : Y`, имеет тип `X -> Y`. В программировании понятие функций часто трактуется шире и включает в себя последовательные (“пошаговые”) алгоритмы, взаимодействующие с внешней средой. Для них мы будем использовать сигнатуры вида `f : Env.(X)-> Y`. Они похожи на функции тем, что принимают аргумент типа `X` и возвращают аргумент типа `Y`, но отличаются тем, что в процессе могут взаимодействовать со внешней средой, описываемой интерфейсом Env. Они могут не принимать значений (`randomBit : RandomGenerator.()-> Boolean`) или не возвращать значений (`print : Console.(String)-> ⊤`). В последнем случае они как бы возвращают значение, только это всегда одно и то же значение `Done` — единственное возможное значение типа `⊤`. Они также могут быть принципиально незавершающимися — таковы, например, команды `break`, или `throw`. Для записи их сигнатур требуется пустой тип ⊥, вовсе не содержащий значений: `break : Loop.()-> ⊥`, `throw : Catcher.(Exception)-> ⊥`. Коль скоро тип `⊥` не содержит значений, функции с таким типом значений просто не имеют способа завершиться.

В языке, поддерживающем такие сигнатуры, мы бы без проблем можем запрашивать хоть аргумент `condition : T -> Boolean`, хоть аргумент типа `CustomEnv.(X)-> Y`,
где
```kotlin
interface CustomEnv {
  fun warn(msg : String) : ⊤
  fun fail(msg : String) : ⊥
}
```

Но как быть, если наш язык программирования не имеет нативной поддержки таких “функций”? В этом случае нам не обойтись без того, чтобы
описывать код как данные. Чтобы принимать в качестве аргументов блоки исполняемого кода, нам придётся определить тип `Expr` выражений языка, доступного для использования в этих блоках. Это параметризованный тип: `Expr<T>` содержит выраженя “типа `T`”.
– Мы должны иметь возможность использовать любое значение `x : T` базового языка в качестве выражения, т.е. у нас должна быть операция “поднятия” `lift(x : T) : Expr<T>`.
– Если у нас есть выражение `f : Expr<X>` и выражение с параметром `g(x : T) : Expr<Y>`, мы хотим чтобы можно было сформировать из них выражение `let x = f(); g(x)`, то есть нам нужна операция последовательной композиции выражений `concatenate(f : Expr<X>, g : X -> Expr<Y>) : Expr<Y>`.

Разумеется, как и для строк, конкатенация должна быть ассоциативной. У строк конкатенация имеет ещё и нейтральный элемент — пустую строку.
В нашем случае тоже есть нейтральный элемент. Им служит операция поднятия:
```
concatenate(f : Expr<X>, lift) = f
concatenate(lift(x), g) = g(x)
```

Математики (в частности) изучают алгебраические структуры, среди которых одна из самых простых называется моноидом.
Моноид это тип T, снабженный ассоциативной операцией, имеющей нейтральный элемент.
Базовый пример моноида — строки с операцией конкатенации.

У структуры, которая нам встретилась, тоже есть название: Монада это параметризованный тип (такой как Expr<T>),
оснащённый ассоциативной операцией параметризованной конкатенации с параметризованным нейтральным элементом.

Тут мы имеем дело с их особенно гармоничной разновидностью — сопряженными монадами. То есть такими монадами Expr,
у которых есть сопряженная комонада (назовём её Env). Вместо того, чтобы давать формальное определение комонад,
я упомяну что сопряженные комонады всегда можно интерпретировать как интерфейсы в объектно-ориентированных языках
программирования. Таким образом практический смысл сопряженности попросту в том, что `Expr<T>` можно эквивалентно
охарактеризовать как `Env.()-> T` в языках, поддерживающих строго-типизированные интерактивные функции.

В языках, с нативной поддержкой `CustomEnv.(X)-> Y` (например, Kotlin) у нас нет потребности делать всё это вручную,
так зачем же тогда вообще знать о монадах? Этот вопрос сродни тому, зачем учиться складывать числа в столбик, когда
есть калькуляторы. Умение складывать в столбик даёт понимание того, как вообще работает сложение, а хорошее, —
в идеале, доведённое до уровня интуиции, — понимание устройства и свойств сопряженных монад это ключ к написанию
продуманных библиотек, фреймворков и API.

* * *

Компилируемые языки программирования естественно рассматривать как развитые формы макроассемблера: все конструкции в них суть
“синтаксический сахар”, упрощаемый в ходе компиляции до команд, исполняемых процессором. Конструкции языка характеризуются их
трансляцией в машинные команды. С этой точки зрения принципы структурного программирования, такие как лексический скоупинг,
условные выражения, циклы и процедуры/сопроцедуры, выглядят как некий исторически сформировавшийся набор конструкций, по
“сложным причинам” образующих согласованную систему. Чтобы увидеть чёткую и ясную картину происходящего, увидеть лес за
деревьями, нужно взглянуть с другой, более абстрактной точки зрения. Описанный выше подход позволяет встраивать последовательные
алгоритмы в чистые языки программирования, и предоставляет ту самую абстрактную точку зрения, позвояляя охарактеризовать конструкции
языка через их композициональное поведение.
