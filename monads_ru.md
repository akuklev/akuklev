(Ко)Монады в программировании
=============================

Компилируемые языки программирования естественно рассматривать как развитые формы макроассемблера: все конструкции в них суть
“синтаксический сахар”, упрощаемый в ходе компиляции до команд, исполняемых процессором. Элементы структурного программирования,
такие как лексический скоупинг и замена goto на условные выражения, циклы и процедуры/сопроцедуры, с этой точки зрения выглядят
как некий исторически сформировавшийся набор конструкций, по “сложным причинам” образующих согласованную систему. Это типичный
случай, когда “за деревьями не видно леса”: если взглянуть с другой, более абстрактной точки зрения, можно увидеть чёткую и
ясную картину происходящего. Такую точку зрения даёт механизм, позволяющий встаивать расширения в подлежащий язык программирования.


Прежде чем я начну, давайте договоримся об обозначениях. Обозначение `f : X -> Y` мы будем использовать для настоящих (как в математике) функций
из типа `X` в тип `Y`. Сигнатуру вида `f : Env.(X)-> Y` мы будем использовать для (последовательных) “интерактивных” функций. Эти штуковины похожи на функции тем, что принимают аргумент типа `X` и возвращают аргумент типа `Y`, но отличаются тем, что в процессе могут взаимодействовать со внешней средой, описываемой интерфейсом Env. Интерактивные функции могут не принимать значений (`randomBit : RandomGenerator.()-> Boolean`) или не возвращать значений (print : Console.(String)-> ⊤). В последнем случае они как бы возвращают значение, только это всегда одно и то же значение `Done` типа `⊤`, не содержащего других значений. Интерактивные функции также могут быть принципиально незавершающимися — таковы, например, команды `break`, или `throw`. Для записи их сигнатур требуется тип пустой ⊥, вовсе не содержащий значений: `break : Loop.()-> ⊥`, `throw : Catcher.(Exception)-> ⊥`. Коль скоро тип `⊥` не содержит значений, функции с таким типом значений просто не имеют способа завершиться.

Строго-типизированные интерактивные функции на данный момент не поддерживаются в полной мере ни в одном распространённом языке программирования. В большинстве языков имеется один тип `X -> Y` как правило неявно обозначающий `GlobalEnv.(X) -> Y`, где `GlobalEnv` это интерфейс-помойка, содержащий одновременно всё с чем только можно взаимодействовать, включая все доступные в данном контексте объекты в памяти компьютера, операционную систему и сеть. В чистых функциональных языках `X -> Y` это тип функций в математическом смысле, и нет встроенного способа говорить об интерактивных функциях. 

Как бы то ни было, при создании библиотек и API нередко хочется принимать в качестве аргумента блок исполняемого кода.
Возьмём хотя бы функцию `filter(collection, condition)`, фильтрующую какой-то набор значений фиксированного типа `T` при помощи условия `condition : T -> Boolean`.
В качестве “условия” передаётся исполняемый блок кода, который можно применить к значению типа `T` и получить ответ убрать его из набора или оставить.
Иногда этого не хватает: хочется, чтобы принимаемый “блок исполняемого кода” мог содержать дополнительные операции.
Например `warn(msg : String)` и `fail(msg : String)` или `setStatus(s : S)` и `getStatus() :  S`.

В языке, поддерживающем строго-типизированные интерактивные функции, мы бы просто могли требовать аргумент типа `CustomEnv.(X)-> Y`,
сперва определив интерфейс
```kotlin
interface CustomEnv {
  fun warn(msg : String) : ⊤
  fun fail(msg : String) : ⊥
}
```

Но как быть, если наш язык программирования не имеет нативной поддержки строго-типизированных интерактивных функций?

Нам потребуется определить тип `Expr` выражений расширенного языка, точнее говоря полиморфный тип `Expr<T>` выражений типа `T`.
– Любое выражение `x : T` базового языка должно автоматически является выражением расширенного языка: у нас должна быть операция “поднятия” `lift(x : T) : Expr<T>`.
– Если у нас есть выражение `f : Expr<X>` и выражение с параметром `g(x : T) : Expr<Y>`, мы хотим чтобы можно было сформировать из них выражение `let x = f(); g(x)`,
то есть нам нужна операция последовательной композиции выражений `concatenate(f : Expr<X>, g : X -> Expr<Y>) : Expr<Y>`.

Разумеется, как и для строк, конкатенация должна быть ассоциативной. У строк конкатенация имеет ещё и нейтральный элемент — пустую строку.
В нашем случае нейтральным элементом конкатенации должна являться операция поднятия:
```
concatenate(f : Expr<X>, lift) = f
concatenate(lift(x), g) = g(x)
```

Математики (в частности) изучают алгебраические структуры, среди которых одна из самых простых называется моноидом.
Моноид это тип T, снабженный ассоциативной операцией, имеющей нейтральный элемент.
Базовый пример моноида — строки с операцией конкатенации.

У структуры, которая нам встретилась, тоже есть название: Монада это параметризованный тип (такой как Expr<T>),
оснащённый ассоциативной операцией параметризованной конкатенации с параметризованным нейтральным элементом.

Отметим, что мы имеем дело с их особенно гармоничной разновидностью — сопряженными монадами. То есть такими монадами Expr, у которых есть сопряженная комонада (назовём её Env). Вместо того, чтобы давать формальное определение комонад, я упомяну что сопряженные комонады всегда можно интерпретировать как интерфейсы в объектно-ориентированных языках программирования. Таким образом практический смысл сопряженности попросту в том, что `Expr<T>` можно эквивалентно охарактеризовать как `Env.()-> T` в языках, поддерживающих строго-типизированные интерактивные функции.

* * *

Если в языках, с типизированными интерактивными функциями (например, Kotlin) задача решается без упоминания монад, то зачем о них вообще знать?

Во-первых хорошее понимание (в идеале, доведённое до уровня интуиции) устройства свойств сопряженных монад  — ключ к написанию корректных библиотеку и API, которые нуждаются в “исполняемых блоках кода с дополнениями“.

Во-вторых, монады позволяют встраивать последовательные алгоритмы в чистые языки программирования.
Чем же это так полезно, если на практике можно просто использовать императивный язык и не морочить себе голову?



Понимание монадической трансляции заменяет непрозрачное понимание такого рода, 
