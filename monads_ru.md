(Ко)Монады в программировании
=============================

Прежде чем я начну, давайте договоримся об обозначениях. Обозначение `f : X -> Y` мы будем использовать для настоящих (как в математике) функций
из типа `X` в тип `Y`. Сигнатуру вида `f : Env.(X)-> Y` мы будем использовать для “интерактивных” функций. Эти штуковины похожи на функции тем, что принимают аргумент типа `X` и возвращают аргумент типа `Y`, но отличаются тем, что в процессе могут взаимодействовать со внешней средой, описываемой интерфейсом Env. Интерактивные функции могут не принимать значений (`randomBit : RandomGenerator.()-> Boolean`) или не возвращать значений (print : Console.(String)-> ⊤). В последнем случае они как бы возвращают значение, только это всегда одно и то же значение `Done` типа `⊤`, не содержащего других значений. Интерактивные функции также могут быть принципиально незавершающимися — таковы, например, команды `break`, или `throw`. Для записи их сигнатур требуется тип пустой ⊥, вовсе не содержащий значений: `break : Loop.()-> ⊥`, `throw : Catcher.(Exception)-> ⊥`. Коль скоро тип `⊥` не содержит значений, функции с таким типом значений просто не имеют способа завершиться.

Строго-типизированные интерактивные функции на данный момент не поддерживаются в полной мере ни в одном распространённом языке программирования. В большинстве языков имеется один тип `X -> Y` как правило неявно обозначающий `GlobalEnv.(X) -> Y`, где `GlobalEnv` это интерфейс-помойка, содержащий одновременно всё с чем только можно взаимодействовать, включая все доступные в данном контексте объекты в памяти компьютера, операционную систему и сеть. В чистых функциональных языках `X -> Y` наоборот обозначает тип функций в математическом смысле, и нет встроенного способа говорить об интерактивных функциях. 

Как бы то ни было, при создании библиотек и API нередко хочется принимать в качестве аргумента блок исполняемого кода.
Возьмём хотя бы функцию `filter(collection, condition)`, фильтрующую какой-то набор значений фиксированного типа `T` при помощи условия `condition : T -> Boolean`.
В качестве “условия” передаётся исполняемый блок кода, который можно применить к значению типа `T` и получить ответ убрать его из набора или оставить.
Иногда этого не хватает: хочется, чтобы принимаемый “блок исполняемого кода” мог содержать дополнительные операции.
Например `warn(msg : String)` и `fail(msg : String)` или `setStatus(s : S)` и `getStatus(s : S)`.


Нам потребуется определить тип `Expr` выражений расширенного языка, точнее говоря полиморфный тип `Expr<T>` выражений типа `T`.
– Любое выражение `x : T` базового языка должно автоматически является выражением расширенного языка: у нас должна быть операция “взятия в кавычки”: `quote(x : T) : Expr<T>`.
– Если у нас есть выражение `f : Expr<X>` и выражение с параметром `g(x : T) : Expr<Y>`, мы хотим чтобы можно было сформировать из них выражение `let x = f(); g(x)`,
то есть нам нужна операция последовательной композиции выражений `concatenate(f : Expr<X>, g : X -> Expr<Y>) : Expr<Y>`.

Разумеется, как и для строк, конкатенация должна быть ассоциативной. У строк конкатенация имеет ещё и нейтральный элемент — пустую строку.
В нашем случае нейтральным элементом конкатенации должна являться операция `quote`:
```
concatenate(f : Expr<X>, quote) = f
concatenate(quote(x), g) = g(x)
```

Математики (в частности) изучают алгебраические структуры, среди которых одна из самых простых называется моноидом.
Моноид это тип T, снабженный ассоциативной операцией, имеющей нейтральный элемент.
Базовый пример моноида — строки с операцией конкатенации.

У структуры, которая нам встретилась, тоже есть название: Монада это параметризованный тип (такой как Expr<T>),
оснащённый ассоциативной операцией параметризованной конкатенации с параметризованным нейтральным элементом.

Отметим, что мы имеем дело с их особенно гармоничной разновидностью — сопряженными монадами.
Чтобы дать формальное определение сопряженности, мне сейчас пришлось бы описать ещё одну непростую математическую структуру под названием “комонада”.
Вместо этого я просто скажу, что сопряженные комонады всегда можно интерпретировать как интерфейсы объектов в объектно-ориентированных языках.
Таким образом практический смысл сопряженности состоит в том, что в объектно-ориентированных языках наподобие Kotlin, мы можем охарактеризовать
выражения расширенного языка как процедуры подлежащего языка, взаимодействующие с объектом заданного интерфейса. В нашем примере с `warn` и `fail`:
```kotlin
interface C {
  def warn(msg : String) : Unit
  def fail(msg : String) : Void
}
typealias Expr<T> = (this : C)-> T
```
— то есть внутри тела `Expr<T>` можно кроме прочего использовать операцию `warn` не возвращающую ничего, и операцию `fail`, никогда не возвращающую
значение — `Void` это “пустой тип”, в нём нет значений и соответственно их невозможно вернуть.

Такой подход автоматически даст нам операции взятия в кавычки и последовательной композиции, и казалось бы незачем упоминать о монадах.
Однако хорошее понимание (в идеале, доведённое до уровня интуиции) устройства свойств сопряженных монад  — ключ к написанию корректных
библиотеку и API, которые нуждаются в “исполняемых блоках кода с дополнениями“.

Отметим важнейший частный случай их в программировании: они позволяют встраивать последовательные алгоритмы в чистые языки программирования.
Чем же это так полезно, если на практике можно просто использовать императивный язык и не морочить себе голову?

Императивные языки программирования исторически возникли как развитые формы макроассемблера, и компилируемые языки в сущности остаются им.
Все конструкции в них можно рассматривать как “синтаксический сахар”, упрощаемый в ходе компиляции до команд, исполняемых процессором.
Принципы структурного программирования (лексический скоупинг, замена goto на условные выражения, циклы и процедуры/сопроцедуры) с этой
точки зрения выглядят как некий “исторически сформировавшийся набор конструкций, по сложным причинам образующих согласованную систему“.

Понимание монадической трансляции заменяет непрозрачное понимание такого рода, ясном и исчерпывающим обоснованием структурного программирования.
