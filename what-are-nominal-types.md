Что такое номинальные типы?
===========================

В таких языках как Java или C# принято вводить классы вроде `Point2d(x : Real, y : Real)` и `Rectangle(width : Real, height : Real)`, тогда как во многих других языках для того и для другого просто используют тип “пара вещественных чисел”, Real × Real. Это отражает два подхода к составным типам данных — структурный и номинальный. В первом случае мы обращаем внимание только на то, как тип данных составлен, во втором — приписываем типу концептуальное значение.

Иногда пара чисел это просто пара чисел, но иногда полезно приписать паре ей концептуальное значение, чтобы сигнатура того или иного метода сообщала потенциальному её пользователю дополнительную информацию — скажем подразумеваются ли координаты точки `Point2d` или размеры прямоугольника `Size2d`. Такой подход позволяет отлавливать на этапе компиляции ошибки, когда пользователь по невнимательности пытается использовать, скажем, координаты в качестве размеров, или наоборот.

Номинальные типы впервые стали применяться задолго до появления программирования: в физике, где они называются физическими величинами. Наряду со структурным типом `Real` вещественных чисел (используемым для в физике для безразмерных физических величин), в физике используются номинальные типы `Length(r : Real)`, `Duration(r : Real)`, `Velocity(r : Real)`, `Acceleration(r : Real)`, `Energy(r : Real)`, etc. физических величин, имеющих единицы измерения. Структурно эти номинальные типы представляют из себя вещественные числа, выражающее значение соответствующей величины в стандартных для данной величины единицах измерения. В физике также встречаются и номинальные типы, привязанные к системе отсчёта `s : ReferenceFrame`: `s.Timestamp(t : Real)`, `s.Position(x y z : Real)`, `s.Velocity(x y z : Real)`, `s.Acceleration(x y z : Real)`. Такие номинальные типы (такие в смысле зависимые от значения, в данном случае от `s`) были впервые введены в языке Scala под названием path-dependent types, в данном случае они позволяют позаботиться о том, что положение или скорость, измеренные в одной системе отсчёта, не будут случайно использованы в другой системе отсчёта без соответствующего преобразования координат.

Чем же являются номинальные типы со структурной точки зрения?

Чтобы разобраться с этим, нам понадобится ознакомиться с понятием typeclass'ов, впервые введённом в языке Haskell и родственных ему языках, но используемом и в языке Scala.

§ Typeclasses
-------------


TODO Вывести главный тезис:
Type members в рекордах это синтаксический сахар для полиморфных рекордов с параметрами, а path-dependent types суть синтаксический сахар над такими параметрами. Пример дешугаринга:
```
@Structire Monoid:
  Carrier : *
  compose : Carrier² -> Carrier
  unit : Carrier
  ...
  
===
@Structire Monoid[Carrier : *]:
  compose : Carrier² -> Carrier
  unit : Carrier
  ...
```

```
f(m : Monoid, a b : m.Carrier) : m.Carrier
===
f[Carrier : *](m : Monoid[Carrier], a b : Carrier) : Carrier
```

```
@Structure Group:
  m : Monoid
  inv : Monoid.Carrier -> Monoid.Carrier
  ...
  
===
@Structure Group[MonoidCarrier : *]:
  m : Monoid[MonoidCarrier]
  inv : MonoidCarrier -> MonoidCarrier
  ...
```

```
f(g : Group, el : g.m.Carrier)
===
f[T : *](g : Group[MonoidCarrier = T], a b : T)
```

Если type members снабженны теми или иными конструкторами и геттерами, то они дешугарятся в функции внутри соответствующего рекорда. Пример desugared системы отсчёта:
```
@Structure ReferenceFrame[Timestamp Position Velocity Acceleration : *]:
   mkTimestamp(r : Real) -> Timestamp
   mkPosition(x y z : Real) -> Position
   ...
```
С path dependent nominal types разобрались — это просто `type members` их носителей. Но как же быть с “глобальными” номинальными типами, у которых как бы нет “носителя”?

Модули (замкнутые кусочки библиотек или приложений) суть структуры с дефолтной имплементацией. Структура задаёт сигнатуры определяемых внутри модуля функций и типов, а дефолтная имплементация — конкретные реализации. Глобальные номинальные типы (такие как Length, Velocity, etc.) суть type members модулей, в которых они определены. Когда мы импортим тот или иной модуль `Lib` в наш модуль, мы делаем весь наш модуль имплицитно зависимым от (дефолтного) инстанса `lib : Lib`, и всякое употребление функции `f` из модуля либ дешугарится в fully qualified `lib.f`, всякое использования типов из модуля `T` дешугарится в `lib.T`. Таким образом “глобальные” номинальные типы сводятся к path dependent nominal types.
